```{r, echo=FALSE}
# source('reportEnvironment.R'); build.report("dami_nissinen_2", c(15), do.pdf=FALSE, toc=TRUE);
```
.  

DAMI_2 - algorithm implementation - Arto Nissinen
=================================================

1. Libraries
-----------

```{r}
library('knitr') 
library('RColorBrewer')
library('arules')
mycolors <- brewer.pal(8, "Dark2")
# sessionInfo()
```

2. Own implementation
----------------------

* Used data-structures: from R package 'arules' (itemMatrix, itemsets, transactions) that all use sparse-matrix implementation 'ngCMatrix' from the R package 'Matrix'.
* Why? I wanted to learn how to use sparse-matrices and S4-objects.
* Pros: Efficient memory usage. Easy to plot debug-visualizations.
* Cons: Unnecessary complexity for data this small.
* Used: from the R arules-library read.transactions() and support() to count supports, which resulted in considerable speed-up.
```{r, results='asis'}
source('arto_implementation.R')
mycat.monospace('arto_implementation.R')
```

3. Trying implementation out
----------------------
```{r}
minsup <- 0.30 # minimal treshold that still yields a 4-itemset
mink   <- 1    # 1-itemsets are not very interesting
maxk   <- 15   # just something big enough

# Reading the data in
courses.tr <- read.transactions('courses_num.txt', rm.duplicates=TRUE)
summary(courses.tr)
image(courses.tr[order(size(courses.tr), decreasing=T)[1:500],])
# ---- big matrix at the end of the document ----
```

```{r}
# reference results from library-algorithm
# system.time( ret.eclat <- eclat(courses.tr, parameter=list(support=minsup)) )
# summary(ret.eclat)
# dim(items(ret.eclat))

# own algorithm
# system.time( ret <- arto.apriori(courses.tr, minsup=minsup, mink=mink, maxk=maxk) )
# temp <- ret$fisets
# inspect(head(sort(temp, by="support"), n=3))
# image(items(sort(temp, by="support")))

```

4. Big Matrix of transactions x courses
----------------------
```{r, bigmatrix, fig.height=180, results='hide'}
image(courses.tr[order(size(courses.tr), decreasing=T),])
```
