DAMI_2 - algorithm implementation - Arto Nissinen
=================================================

Contents
--------
1. Libraries
2. My implementation
3. Benchmarking

------------

1. Libraries
------------
```{r}
# report build command: # setwd("~/atlinks/dami-qame/dami_qame_2/arto"); source('../reportEnvironment.R'); build.report("dami_nissinen_2", c(15), do.pdf=TRUE, toc=TRUE);

# libraries
# presentation
library('knitr') 
library('RColorBrewer')
opts_chunk$set(fig.width=10, fig.height=6)
mycolors <- brewer.pal(8, "Dark2")
# computation
library('Rcpp')
library('arules')
Sys.setenv("PKG_CXXFLAGS"="-std=c++11")
# sessionInfo()
```


2. My implementation
----------------------


### 2.1. Personal Goals
Explore and learn both course-specific and general concepts/tools. Course-specific concepts include frequent itemsets, association rules, closed itemsets and maximal itemsets. General tools include multiple programming language integration and leveraging existing libraries. 


### 2.2. Design choices

#### Algorithms: 
I implemented the apriori algorithm for frequent itemsets mining and association rules mining. The library mines only for rules whose consequent is of size 1, so I did the same.

#### Languages: 
Combination of R and C++ using R 'Rcpp' library.

#### Libraries: 
I used R library 'arules' to read in the data, to do support-counting, set-operations etc., to verify the results from my implementations, for visualizations and for ideas how these algorithms/datastructures are implemented in real life.


### 2.3. Findings

#### Course-specific concepts findings:
I gained intuition about the concepts by trying things out. We will include more of this in our group report.

#### General tools findings:
Compared to the library implementations, my old implementation was about 500 times slower and my new implementation is about 50 times slower. I.e. my new implementation is about 10 times faster than my old implementation.

R runs slow on the parts that require explicit looping or mutating/growing datastructures. However, implementing those parts as C++ functions and calling those functions from R turned out to be relatively easy and hassle-free using the 'Rcpp' library. These "tight-spot" C++ functions ran e.g. roughly 200 times faster than the equivalent R functions.

Most performance was lost when converting between regular R list of integer vectors and  'itemMatrix' from 'arules' library. The library implementations utilize the underlying sparse 'ngCMatrix' from the R package 'Matrix'. I used refular lists because I assumed that trying to use 'ngCMatrix' properties myself would distract me too much from learning the high level concepts. I am satisfied with this combination that allowed reasonable performance and good visualization and debugging.


### 2.4. C++ source code
```{r, results='asis'}
sourceCpp('arto_implementation.cpp')
mycat.monospace('arto_implementation.cpp', 'cpp')
```

### 2.5. R source code
```{r, results='asis'}
source('arto_implementation.R')
mycat.monospace('arto_implementation.R')
```

3. Benchmarking
----------------------

### 3.1. Initialization
```{r}
# common parameters:
minsup <- 0.08 # yields also non-closed frequent itemsets
mink   <- 1    # all
maxk   <- 15   # just something big enough
minconfidence <- 0.8 # default in library

# debug parameters for library implementations
paraml <- list(support=minsup, ext=TRUE)
contrl <- list(verbose=FALSE)

# Reading the data in
system.time( courses.tr <- read.transactions('../courses_num.txt', rm.duplicates=TRUE) )
dim(courses.tr)
```

### 3.2. Frequent itemsets
```{r}
system.time( fisets.bm <- eclat(courses.tr, parameter=paraml, control=contrl) )
system.time( ret <- arto.apriori(courses.tr, minsup=minsup, mink=mink, maxk=maxk) )
fisets.arto <- ret$fisets
setequal(fisets.arto, fisets.bm)
```

### 3.3. Association rules
```{r}
system.time( rules.bm <- ruleInduction(fisets.bm, confidence=minconfidence, control=contrl) )
system.time( rules.arto <- arto.ruleInduction(fisets.arto, courses.tr, minconfidence=minconfidence))
setequal(rules.arto, rules.bm)
```

### 3.4. Closed itemsets
```{r}
system.time( closed.bm <- apriori(courses.tr, parameter=c(paraml, target="closed"), control=contrl) )
```

### 3.5. Maximal itemsets
```{r}
system.time( maximal.bm <- apriori(courses.tr, parameter=c(paraml, target="maximal"), control=contrl) )
```

### 3.6. Junkyard
```{r}
# summary(fisets.bm)
# summary(closed.bm)
# summary(maximal.bm)
# summary(setdiff(fisets.bm, closed.bm))
# summary(rules.bm)

inspect(head(sort(rules.arto, by="support"), n=2))
inspect(head(sort(rules.bm, by="support"), n=2))
# image(items(sort(temp, by="support")))

system.time( interestMeasure(fisets.arto, c("allConfidence"), courses.tr) )

```

```{r, bigmatrix, fig.height=180, results='hide'}
# image(courses.tr[order(size(courses.tr), decreasing=T),order(itemFrequency(courses.tr), decreasing=T)])
```
